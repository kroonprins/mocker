= Mocker
:source-highlighter: highlightjs
:toc: left

Mocker consists of:

* A UI for management
* A mock server which responds to requests based on rules. Those rules are described in yaml files.
* A learning mode reverse proxy server. In learning mode, requests to the real server that the mock server should mock are captured. From the UI these captured requests can be transformed into rules for the mock server.
* A specific version of the mock server for use in javascript base unit and integration tests.

== Rules

Rules for the mock server are stored in yaml format. One yaml file per rule. A rule specifies the response that the mock server should give for a given request. A request is defined by an HTTP method and a path. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-very-basic-rule.yaml[a-very-basic-rule.yaml]
[source,YAML]
----
name: basic rule
request:
  path: /get
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  body: the response body
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/get
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 17
Date: Sat, 08 Dec 2018 21:46:59 GMT
Connection: keep-alive

the response body
----

=== Templating

No 2 rules for the same request should be created, instead the response can be made dynamic based on the request context using templating. The currently supported template engine is https://mozilla.github.io/nunjucks/[nunjucks]. The templating environment is filled with an object "req" on which all the attributes of the request are present (req.query, req.headers, req.body, req.cookies) and "res" with an object containing the response attributes. These 2 objects are the request and response object of the https://expressjs.com/[express] server, so all possible properties can be found in the express documentation (see https://expressjs.com/en/api.html#req[here] for request properties, and https://expressjs.com/en/api.html#res[here] for response properties). For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-basic-rule-with-templating.yaml[a-basic-rule-with-templating.yaml]
[source,YAML]
----
name: basic rule with templating
request:
  path: /templating
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: "{{req.query.q}}"
  body: received a header 'h' with value {{req.headers.h}} and response status code of {{res.statusCode}} is set
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/templating?q=206 -H "h: xyz"
HTTP/1.1 206 Partial Content
Content-Type: text/plain; charset=utf-8
Content-Length: 75
Date: Sat, 08 Dec 2018 22:04:40 GMT
Connection: keep-alive

received a header 'h' with value xyz and response status code of 206 is set
----

If no templating is required then templetingEngine should be set to 'none'.

Note: req.body is parsed using express body-parser module. The structure of req.body depends on the input content-type header on the request.

=== Conditional response

Sometimes the complete response should be different based on a condition. Instead of templating every response property with this condition a "conditional response" can be defined in the rule. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-conditional-response.yaml[a-rule-with-conditional-response.yaml]
[source,YAML]
----
name: Conditional response
request:
  path: /conditional
  method: GET
conditionalResponse:
  templatingEngine: nunjucks
  response:
    - condition: "{{req.query.id == 'id1'}}"
      contentType: application/json
      statusCode: "200"
      body: |
        {
          "data": "id1's data"
        }
    - condition: "{{req.query.id == 'id2'}}"
      contentType: application/json
      statusCode: "200"
      body: |
        {
          "data": "id2's data"
        }
    - condition: true
      contentType: text/plain
      statusCode: "404"
      body: The item with id '{{req.query.id}}' does not exist
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/conditional?id=id1
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 27
Date: Sun, 09 Dec 2018 20:08:47 GMT
Connection: keep-alive

{
  "data": "id1's data"
}

$ curl -i -X GET http://localhost:3000/conditional?id=id2
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 27
Date: Sun, 09 Dec 2018 20:08:51 GMT
Connection: keep-alive

{
  "data": "id2's data"
}

$ curl -i -X GET http://localhost:3000/conditional?id=id3
HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
Content-Length: 37
Date: Sun, 09 Dec 2018 20:16:42 GMT
Connection: keep-alive

The item with id 'id3' does not exist
----

The conditions are evaluated in the order they are defined, so the first match is returned. It is best to always define as last conditional response one that equals 'true' so that there is always at least one matching condition.

Compared with implementing the same with plain templating, this would have been something like:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-conditional-response-with-plain-templating.yaml[a-rule-with-conditional-response-with-plain-templating.yaml]
[source,YAML]
----
name: Conditional response without using conditionalResponse
request:
  path: /conditional-without-using-conditionalresponse
  method: GET
response:
  templatingEngine: nunjucks
  contentType: "{% if req.query.id == 'id1' or req.query.id == 'id2' %}application/json{% else %}text/plain{% endif %}"
  statusCode: "{% if req.query.id == 'id1' or req.query.id == 'id2' %}200{% else %}404{% endif %}"
  body: |
    {%- if req.query.id == 'id1' -%}
    {
      "data": "id1's data"
    }
    {%- elif req.query.id == 'id2' -%}
    {
      "data": "id2's data"
    }
    {%- else -%}The item with id '{{req.query.id}}' does not exist{%- endif -%}
----

Which has a lot of repetition of the if-else and is more difficult to read.

=== Response headers and cookies

Response headers and cookies can be defined. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-response-headers-and-cookies.yaml][a-rule-with-response-headers-and-cookies.yaml]
[source,YAML]
----
name: response headers and cookies
request:
  path: /response-headers-and-cookies
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  headers:
    - name: X-header1
      value: header1
    - name: X-header2
      value: header2
  cookies:
    - name: cookie1
      value: value1
      properties:
        secure: true
    - name: cookie2
      value: value2
      properties:
        httpOnly: true
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/response-headers-and-cookies
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
X-header1: header1
X-header2: header2
Set-Cookie: cookie1=value1; Path=/; Secure
Set-Cookie: cookie2=value2; Path=/; HttpOnly
Content-Length: 0
Date: Sun, 09 Dec 2018 18:41:38 GMT
Connection: keep-alive
----

The possible properties that can be set for cookies are the standard cookie properties. See for example https://expressjs.com/en/api.html#res.cookie[here].
Templating can also be applied on the name and values of the headers/cookies.

=== Path parameters

Path parameters in the request path can be defined using the express syntax (see https://expressjs.com/en/api.html#app.param[here]).
For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-path-parameter.yaml[a-rule-with-path-parameter.yaml]
[source,YAML]
----
name: with path parameters
request:
  path: /path-parameter/:p1/:p2
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  body: |
    parameter p1: {{req.params.p1}}
    parameter p2: {{req.params.p2}}
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/path-parameter/parameter1/parameter2
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 50
Date: Sun, 09 Dec 2018 19:49:27 GMT
Connection: keep-alive

parameter p1: parameter1
parameter p2: parameter2
----

More generally the https://expressjs.com/en/guide/routing.html[express routing] constructs can be used in the request path. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-express-routing-regex.yaml[a-rule-with-express-routing-regex.yaml]
[source,YAML]
----
name: path using express routing regex
request:
  path: /regex/ab(cd)?e
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  body: this rule's response
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/regex/abe
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 20
Date: Sun, 09 Dec 2018 19:55:17 GMT
Connection: keep-alive

this rule's response

$ curl -i -X GET http://localhost:3000/regex/abcde
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 20
Date: Sun, 09 Dec 2018 19:55:28 GMT
Connection: keep-alive

this rule's response
----


=== Latency

A fixed or random latency can be defined. The value of the latency is in milliseconds.

Example fixed latency:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-fixed-latency.yaml[a-rule-with-fixed-latency.yaml]
[source,YAML]
----
name: fixed latency
request:
  path: /fixed-latency
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  fixedLatency:
    value: 1000
----

Gives as result:
[source,console]
----
$ curl -X GET http://localhost:3000/fixed-latency -w "%{time_total}\n"
1,006
----

Example random latency:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-random-latency.yaml[a-rule-with-random-latency.yaml]
[source,YAML]
----
name: random latency
request:
  path: /random-latency
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  randomLatency:
    min: 500
    max: 2000
----

Gives as result:
[source,console]
----
$ for i in $(seq 1 5); do curl -X GET http://localhost:3000/random-latency -w "%{time_total}\n"; done
0,670
1,029
1,919
1,348
1,559
----

Fixed and random latency should not be defined both in a rule. It is one or the other.
Templating can be applied to the value of the latency. For example a random latency could also have been written like this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-templated-latency.yaml[a-rule-with-templated-latency.yaml]
[source,YAML]
----
name: templated latency
request:
  path: /templated-latency
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  fixedLatency:
    value: |
      {% set items = range(500, 2000) %}
      {{ items | random }}
----

Gives as result:
[source,console]
----
$ for i in $(seq 1 5); do curl -X GET http://localhost:3000/templated-latency -w "%{time_total}\n"; done
1,378
1,905
0,667
1,509
0,552
----

[#chapter-templating-helpers]
=== Nunjucks templating helpers

Nunjucks allows to define custom defined functions and filters that can be used in templates. To add extra functions and/or filters, define a file with .mjs extension exporting a HELPERS object. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/templating-helper/template-helpers.nunjucks.mjs[template-helpers.nunjucks.mjs]
[source,javascript]
----
export const HELPERS = {
  filters: {
    appendText: (str, text) => {
      return str + text
    }
  },
  functions: {
    double: (num) => {
      return 2 * num
    }
  }
}
----

The location of the file should then be given as the environment variable TEMPLATING_HELPERS_NUNJUCKS. External npm packages can be used in the templating helper file. See the sections on how start mocker for more information.
The functions and filters can then be used in rule definitions. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-templating-helpers.yaml[a-rule-with-templating-helpers.yaml]
[source,YAML]
----
name: using templating helpers
request:
  path: /templating-helpers
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  body: |
    result of function double: {{ double(req.query.q1) }}
    result of filter appendTest: {{ req.query.q2 | appendText('s') }}
----

Gives as result:
[source,console]
----
$ curl -i -X GET 'http://localhost:3000/templating-helpers?q1=2&q2=sheep'
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 65
Date: Sun, 09 Dec 2018 20:54:54 GMT
Connection: keep-alive

result of function double: 4
result of filter appendTest: sheeps
----

=== Echo server

The mock server can be used as an echo server to inspect all request parameters sent to the mock server. This can for example be useful when testing what headers are added by an api gateway or proxy.
A special template helper function "echo" has been defined and is available by default. To create an echo service, define a rule using the echo function. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-echo-server.yaml[a-rule-with-echo-server.yaml]
[source,YAML]
----
name: echo server
request:
  path: /echo
  method: POST
response:
  templatingEngine: nunjucks
  contentType: application/json
  statusCode: 200
  body: |
    {{ echo(req) }}
----

Gives as result:
[source,console]
----
$ curl -s -X POST 'http://localhost:3000/echo?q1=query1&q2=query2' -H 'content-type: application/json' -H 'X-h1: header1' -H 'X-h2: header2' -b 'c1=cookie1;c2=cookie2' -d '{ "my": { "input": "body" } }' | jq
{
  "method": "POST",
  "path": "/echo",
  "fullPath": "/echo?q1=query1&q2=query2",
  "body": {
    "my": {
      "input": "body"
    }
  },
  "params": {
    "q1": "query1",
    "q2": "query2"
  },
  "headers": {
    "host": "localhost:3000",
    "user-agent": "curl/7.47.0",
    "accept": "*/*",
    "content-type": "application/json",
    "x-h1": "header1",
    "x-h2": "header2",
    "content-length": "29"
  },
  "cookies": {
    "c1": "cookie1",
    "c2": "cookie2"
  }
}
----

[#chapter-projects]
== Projects

Rules are organized by projects. The projects are listed in a yaml file.

The project file in its simplest form looks like this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/projects/projects.yaml[projects.yaml]
[source,YAML]
----
projects:
  - name: examples
    rules:
      - ../rules/*.yaml
----

Each project defines the list of rules that belong to it. Rules can belong to several projects. The rules are reference by the path to the yaml rule file. This path can be an absolute path, or a path relative to the location of the project file. Glob patterns can be used (following the implemantation of the https://www.npmjs.com/package/glob[glob] package).

A more extensive example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/projects/projects-examples.yaml[projects-examples.yaml]
[source,YAML]
----
projects:
  - name: all rules in the rules directory
    rules:
      - ../rules/*.yaml
  - name: all rules in the rules directory and subdirectories
    rules:
      - ../rules/**/*.yaml
  - name: a defined list of rules
    rules:
      - ../rules/a-very-basic-rule.yaml
      - ../rules/a-basic-rule-with-templating.yaml
  - name: the rules containing the word latency or conditional in the file name
    rules:
      - ../rules/*latency*
      - ../rules/*conditional*
----

When using mocker a reference to the project file will always have to be given by setting environment variable MOCKER_PROJECTS_FILE. See below for more info on the different ways to use mocker.

== Mocker UI

Mocker UI is a browser-based UI to manage the projects and rules as described above. Instead of manipulating the yaml files manually, they can be managed from the UI. From the UI a mock server can also be started, as well as the learning mode.
Mocker UI provides:
* A section to manage projects: create new projects, update the name of a project, delete a projects, start a mock server for the project, and start a learnng mode reverse proxy for a project
* For a selected project the mock server rules belonging can be managed: create a rule, update a rule, delete a rule, and create a rule from an existing rule.
* For a selected project the captured requests of the learning mode reverse proxy server can be listed. For a captured request a new rule can be created based on the values of the captured request
* Administrative actions: manage the log level of the application

=== Start using node

Create a new project:

[source,console]
----
$ npm init
----

Install mocker-ui:

[source,console]
----
$ npm install @kroonprins/mocker-ui
----

Add a script to package.json:

[source,json]
----
  "scripts": {
    "start": "mocker-ui"
  }
----

Note: on Windows the shortcut need to be defined as follows instead:

[source,json]
----
  "scripts": {
    "start": "node --experimental-modules .\node_modules\@kroonprins\mocker-ui\start.mjs"
  }
----

Set the required environment variables by exporting them on the command line or by creating a .env file like for example this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-ui/.env[.env]
[source,properties]
----
MOCKER_PROJECTS_FILE=../projects/projects.yaml

TEMPLATING_HELPERS_NUNJUCKS=../templating-helper/template-helpers.nunjucks.mjs
----

After this Mocker UI can be started by running:

[source,console]
----
$ npm start
----

And then opening "http://localhost:3005" in the browser.
Starting Mocker UI will start a UI server on port 3005, an API server on port 3004 and an administration server on port 3001. These ports can be changed by setting environment variables (see below).

Alternatively Mocker UI can also be installed globally:

[source,console]
----
$ npm install -g @kroonprins/mocker-ui
----

And then started as follows:

[source,console]
----
$ mocker-ui
----

[#environment-variables-mocker-ui]
The possible environment variables are:

* *MOCKER_PROJECTS_FILE*: location of the projects file (see xref:chapter-projects[here]). If not provided it defaults to location ./projects/projects.yaml
* *MOCKER_LEARNING_MODE_DB_LOCATION* (optional): if you want to use the learning mode of the server, then add here the name of the file in which the captured requests should be stored. By default this will be ./data/learning_mode.db
* *TEMPLATING_HELPERS_NUNJUCKS* (optional): path to javascript file containing nunjucks templating helper functions/filters (see xref:chapter-templating-helpers[here])
* *MOCKER_RULES_DEFAULT_LOCATION* (optional): set the default location in which the yaml files of the rules will be stored when creating a rule from Mocker UI.
* *MOCKER_UI_SERVER_PORT* (optional): override the default port (3005) used by the UI server.
* *MOCKER_UI_SERVER_BIND_ADDRESS* (optional): bind the UI server to a given address instead of localhost.
* *MOCKER_UI_SERVER_STATICS_LOCATION* (optional): override the location where the UI server statics are located.
* *MOCKER_ADMINISTRATION_SERVER_PORT* (optional): override the default port (3001) used by the administration server.
* *MOCKER_ADMINISTRATION_SERVER_BIND_ADDRESS* (optional): bind the administration server to a given address instead of localhost.
* *MOCKER_API_SERVER_PORT* (optional): override the default port (3004) used by the api server.
* *MOCKER_API_SERVER_BIND_ADDRESS* (optional): bind the api server to a given address instead of localhost.
* *MOCKER_LOG_LEVEL* (optional): set the log level (one of 'error', 'warn', 'info', 'debug', or 'trace')


If the nunjucks templating helpers require any npm packages then these can be added by installing the packages with npm. The templating helpers use modules so the package must be imported using the import syntax. For example:

[source,console]
----
$ npm install cows
----

And then use it in the templating helpers:

[#nunjucks-templating-helper-with-cows]
[source,javascript]
----
import cows from 'cows'

export const HELPERS = {
  functions: {
    printCow: () => {
      const cowsList = cows()
      return cowsList[Math.floor((Math.random() * (cowsList.length - 1)))]
    }
  }
}

----

=== Start using docker

[source,console]
----
docker run --rm \
  -p 3001:3001 -p 3004:3004 -p 8000:3005 -p 8001:8080 \
  -v $(pwd)/projects:/app/projects \
  -v $(pwd)/rules:/app/rules \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/template-helpers.nunjucks.mjs:/app/template-helpers.nunjucks.mjs \
  kroonprins/mocker-ui:latest \
  npm start
----

Ports 3001, 3004 and 3005 must be mapped. The port on which port 3005 maps on the docker host can be chosen freely (port 80002 in the example above). For ports 3004 and 3005 the port must map to the same port on the docker host, but the port can be changed by using the environment variables described xref:environment-variables-mocker-ui[here]. When starting a mock server or the learning mode from Mocker UI then this port must also be mapped. In the example above, from Mocker UI a mock server is started on port 8080 and this is mapped on port 8001 on the docker host.

The projects file and the directory mock server rules must also be mapped into the container via volume mapping. In the example above the projects file is in $(pwd)/projects on the docker host, and the mock server rules are in $(pwd)/rules on the docker host.

The environment variables to configure Mocker UI (see xref:environment-variables-mocker-ui[here]) can be passed as part of the docker run command with the -e option (e.g. docker run -e "TEMPLATING_HELPERS_NUNJUCKS=./template-helpers.nunjucks.mjs" ...) or by putting them in a .env file that is mapped into the container as in the example above.

In case nunjucks templating helpers are used, then the helpers .mjs file should also be mapped in the container as shown in the example above.
If the nunjucks templating helpers require any npm packages then a new image must be built in which the dependency is installed. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-ui-with-docker/Dockerfile[Dockerfile]
[source,properties]
----
from kroonprins/mocker-ui

RUN npm install cows
----

And define a template-helpers.nunjucks.mjs that uses the cows package: see xref:nunjucks-templating-helper-with-cows[here].

Then build the image:

[source,console]
----
docker build -t mocker-ui-with-cows .
----

And define a rule using the templating helper (or create if from the UI after starting it):

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-ui-with-docker/rules/rule-using-nunjucks-templating-helper-with-external-package.yaml[rule-using-nunjucks-templating-helper-with-external-package.yaml]
[source,YAML]
----
name: rule using the printCow templating helper
request:
  path: /cow
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  body: |
    {{printCow()}}
----

And run it:

[source,console]
----
docker run --rm \
  -p 3001:3001 -p 3004:3004 -p 8000:3005 -p 8001:8080 \
  -v $(pwd)/projects:/app/projects \
  -v $(pwd)/rules:/app/rules \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/template-helpers.nunjucks.mjs:/app/template-helpers.nunjucks.mjs \
  mocker-ui-with-cows \
  npm start
----

After starting a mock server on port 8080 binding to 0.0.0.0, then the result is:
[source,console]
----
$ curl -X GET http://localhost:8001/cow
        (__)
        (oo)
*+-------\/
||______||
  ||----||
  OO    OO
 pickup cow
----


== Mock server standalone

A mock server can also be started in standalone mode from the command line.

[#chapter-swagger-ui]
=== Swagger UI

It is possible to start swagger UI next to a mock server. A swagger definition will be generated from the mock server rules. This swagger definition can be consulted from the swagger UI. See chapters below on how to activate the swagger server.

=== Start using node

Create a new project:

[source,console]
----
$ npm init
----

Install mocker-mock-server:

[source,console]
----
$ npm install @kroonprins/mocker-mock-server
----

Add a script to package.json:

[source,json]
----
  "scripts": {
    "start": "mocker-mock-server"
  }
----

Note: on Windows the shortcut need to be defined as follows instead:

[source,json]
----
  "scripts": {
    "start": "node --experimental-modules .\node_modules\@kroonprins\mocker-mock-server\start.mjs"
  }
----

Set the required environment variables by exporting them on the command line or by creating a .env file like for example this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server/.env[.env]
[source,properties]
----
MOCKER_PROJECTS_FILE=../projects/projects.yaml
MOCKER_PROJECT=examples

TEMPLATING_HELPERS_NUNJUCKS=../templating-helper/template-helpers.nunjucks.mjs
----

After this the mock server can be started by running:

[source,console]
----
$ npm start
----

The mock server can then be called on "http://localhost:3000".

Alternatively Mocker mock server can also be installed globally:

[source,console]
----
$ npm install -g @kroonprins/mocker-mock-server
----

And then started as follows:

[source,console]
----
$ mocker-mock-server
----

[#environment-variables-mocker-mock-server]
The possible environment variables are:

* *MOCKER_PROJECTS_FILE*: location of the projects file (see xref:chapter-projects[here]). If not provided it defaults to location ./projects/projects.yaml
* *MOCKER_PROJECT* (optional): reference to the name of the project to run the mock server for.
* *TEMPLATING_HELPERS_NUNJUCKS* (optional): path to javascript file containing nunjucks templating helper functions/filters (see xref:chapter-templating-helpers[here])
* *MOCKER_MOCK_SERVER_PORT* (optional): override the default port (3000) used by the mock server.
* *MOCKER_MOCK_SERVER_BIND_ADDRESS* (optional): bind the mock server to a given address instead of localhost.
* *MOCKER_MOCK_SERVER_WATCH_FOR_FILE_CHANGES* (optional): if set to true, a running mock server will watch the filesystem for changes to project rule files, and automatically restart itself when this happen to load the latest configuration.
* *MOCKER_MOCK_SERVER_SWAGGER_UI_ENABLED* (optional): enable swagger UI on the mock server (see xref:chapter-swagger-ui[here]).
* *MOCKER_MOCK_SERVER_SWAGGER_UI_PORT* (optional): override the default port (3006) used by the swagger UI server.
* *MOCKER_MOCK_SERVER_SWAGGER_UI_BIND_ADDRESS* (optional): bind the swagger UI server to a given address instead of localhost.
* *MOCKER_LOG_LEVEL* (optional): set the log level (one of 'error', 'warn', 'info', 'debug', or 'trace')


If the nunjucks templating helpers require any npm packages then these can be added by installing the packages with npm. The templating helpers use modules so the package must be imported using the import syntax. For example:

[source,console]
----
$ npm install cows
----

And then use it in the templating helpers like was done xref:nunjucks-templating-helper-with-cows[here].

=== Start using docker

== Learning mode standalone

The learning mode reverse proxy can also be started in standalone mode from the command line.

=== Start using node

=== Start using docker

== Use in unit/integration tests
