= Mocker
:source-highlighter: highlightjs
:toc: left

Mocker consists of:

* A UI for management
* A mock server which responds to requests based on rules. Those rules are described in yaml files.
* A learning mode reverse proxy server. In learning mode, requests to the real server that the mock server should mock are captured. From the UI these captured requests can be transformed into rules for the mock server.
* A specific version of the mock server for use in javascript base unit and integration tests.

== Rules

Rules for the mock server are stored in yaml format. One yaml file per rule. A rule specifies the response that the mock server should give for a given request. A request is defined by an HTTP method and a path. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-very-basic-rule.yaml[a-very-basic-rule.yaml]
[source,YAML]
----
name: basic rule
request:
  path: /get
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  body: the response body
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/get
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 17
Date: Sat, 08 Dec 2018 21:46:59 GMT
Connection: keep-alive

the response body
----

=== Templating

No 2 rules for the same request should be created, instead the response can be made dynamic based on the request context using templating. The currently supported template engine is https://mozilla.github.io/nunjucks/[nunjucks]. The templating environment is filled with an object "req" on which all the attributes of the request are present (req.query, req.headers, req.body, req.cookies) and "res" with an object containing the response attributes. These 2 objects are the request and response object of the https://expressjs.com/[express] server, so all possible properties can be found in the express documentation (see https://expressjs.com/en/api.html#req[here] for request properties, and https://expressjs.com/en/api.html#res[here] for response properties). For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-basic-rule-with-templating.yaml[a-basic-rule-with-templating.yaml]
[source,YAML]
----
name: basic rule with templating
request:
  path: /templating
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: "{{req.query.q}}"
  body: received a header 'h' with value {{req.headers.h}} and response status code of {{res.statusCode}} is set
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/templating?q=206 -H "h: xyz"
HTTP/1.1 206 Partial Content
Content-Type: text/plain; charset=utf-8
Content-Length: 75
Date: Sat, 08 Dec 2018 22:04:40 GMT
Connection: keep-alive

received a header 'h' with value xyz and response status code of 206 is set
----

If no templating is required then templetingEngine should be set to 'none'.

Note: req.body is parsed using express body-parser module. The structure of req.body depends on the input content-type header on the request.

=== Conditional response

Sometimes the complete response should be different based on a condition. Instead of templating every response property with this condition a "conditional response" can be defined in the rule. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-conditional-response.yaml[a-rule-with-conditional-response.yaml]
[source,YAML]
----
name: Conditional response
request:
  path: /conditional
  method: GET
conditionalResponse:
  templatingEngine: nunjucks
  response:
    - condition: "{{req.query.id == 'id1'}}"
      contentType: application/json
      statusCode: "200"
      body: |
        {
          "data": "id1's data"
        }
    - condition: "{{req.query.id == 'id2'}}"
      contentType: application/json
      statusCode: "200"
      body: |
        {
          "data": "id2's data"
        }
    - condition: true
      contentType: text/plain
      statusCode: "404"
      body: The item with id '{{req.query.id}}' does not exist
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/conditional?id=id1
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 27
Date: Sun, 09 Dec 2018 20:08:47 GMT
Connection: keep-alive

{
  "data": "id1's data"
}

$ curl -i -X GET http://localhost:3000/conditional?id=id2
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 27
Date: Sun, 09 Dec 2018 20:08:51 GMT
Connection: keep-alive

{
  "data": "id2's data"
}

$ curl -i -X GET http://localhost:3000/conditional?id=id3
HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=utf-8
Content-Length: 37
Date: Sun, 09 Dec 2018 20:16:42 GMT
Connection: keep-alive

The item with id 'id3' does not exist
----

The conditions are evaluated in the order they are defined, so the first match is returned. It is best to always define as last conditional response one that equals 'true' so that there is always at least one matching condition.

Compared with implementing the same with plain templating, this would have been something like:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-conditional-response-with-plain-templating.yaml[a-rule-with-conditional-response-with-plain-templating.yaml]
[source,YAML]
----
name: Conditional response without using conditionalResponse
request:
  path: /conditional-without-using-conditionalresponse
  method: GET
response:
  templatingEngine: nunjucks
  contentType: "{% if req.query.id == 'id1' or req.query.id == 'id2' %}application/json{% else %}text/plain{% endif %}"
  statusCode: "{% if req.query.id == 'id1' or req.query.id == 'id2' %}200{% else %}404{% endif %}"
  body: |
    {%- if req.query.id == 'id1' -%}
    {
      "data": "id1's data"
    }
    {%- elif req.query.id == 'id2' -%}
    {
      "data": "id2's data"
    }
    {%- else -%}The item with id '{{req.query.id}}' does not exist{%- endif -%}
----

Which has a lot of repetition of the if-else and is more difficult to read.

=== Response headers and cookies

Response headers and cookies can be defined. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-response-headers-and-cookies.yaml][a-rule-with-response-headers-and-cookies.yaml]
[source,YAML]
----
name: response headers and cookies
request:
  path: /response-headers-and-cookies
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  headers:
    - name: X-header1
      value: header1
    - name: X-header2
      value: header2
  cookies:
    - name: cookie1
      value: value1
      properties:
        secure: true
    - name: cookie2
      value: value2
      properties:
        httpOnly: true
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/response-headers-and-cookies
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
X-header1: header1
X-header2: header2
Set-Cookie: cookie1=value1; Path=/; Secure
Set-Cookie: cookie2=value2; Path=/; HttpOnly
Content-Length: 0
Date: Sun, 09 Dec 2018 18:41:38 GMT
Connection: keep-alive
----

The possible properties that can be set for cookies are the standard cookie properties. See for example https://expressjs.com/en/api.html#res.cookie[here].
Templating can also be applied on the name and values of the headers/cookies.

=== Path parameters

Path parameters in the request path can be defined using the express syntax (see https://expressjs.com/en/api.html#app.param[here]).
For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-path-parameter.yaml[a-rule-with-path-parameter.yaml]
[source,YAML]
----
name: with path parameters
request:
  path: /path-parameter/:p1/:p2
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  body: |
    parameter p1: {{req.params.p1}}
    parameter p2: {{req.params.p2}}
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/path-parameter/parameter1/parameter2
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 50
Date: Sun, 09 Dec 2018 19:49:27 GMT
Connection: keep-alive

parameter p1: parameter1
parameter p2: parameter2
----

More generally the https://expressjs.com/en/guide/routing.html[express routing] constructs can be used in the request path. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-express-routing-regex.yaml[a-rule-with-express-routing-regex.yaml]
[source,YAML]
----
name: path using express routing regex
request:
  path: /regex/ab(cd)?e
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  body: this rule's response
----

Gives as result:
[source,console]
----
$ curl -i -X GET http://localhost:3000/regex/abe
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 20
Date: Sun, 09 Dec 2018 19:55:17 GMT
Connection: keep-alive

this rule's response

$ curl -i -X GET http://localhost:3000/regex/abcde
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 20
Date: Sun, 09 Dec 2018 19:55:28 GMT
Connection: keep-alive

this rule's response
----


=== Latency

A fixed or random latency can be defined. The value of the latency is in milliseconds.

Example fixed latency:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-fixed-latency.yaml[a-rule-with-fixed-latency.yaml]
[source,YAML]
----
name: fixed latency
request:
  path: /fixed-latency
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  fixedLatency:
    value: 1000
----

Gives as result:
[source,console]
----
$ curl -X GET http://localhost:3000/fixed-latency -w "%{time_total}\n"
1,006
----

Example random latency:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-random-latency.yaml[a-rule-with-random-latency.yaml]
[source,YAML]
----
name: random latency
request:
  path: /random-latency
  method: GET
response:
  templatingEngine: none
  contentType: text/plain
  statusCode: 200
  randomLatency:
    min: 500
    max: 2000
----

Gives as result:
[source,console]
----
$ for i in $(seq 1 5); do curl -X GET http://localhost:3000/random-latency -w "%{time_total}\n"; done
0,670
1,029
1,919
1,348
1,559
----

Fixed and random latency should not be defined both in a rule. It is one or the other.
Templating can be applied to the value of the latency. For example a random latency could also have been written like this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-templated-latency.yaml[a-rule-with-templated-latency.yaml]
[source,YAML]
----
name: templated latency
request:
  path: /templated-latency
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  fixedLatency:
    value: |
      {% set items = range(500, 2000) %}
      {{ items | random }}
----

Gives as result:
[source,console]
----
$ for i in $(seq 1 5); do curl -X GET http://localhost:3000/templated-latency -w "%{time_total}\n"; done
1,378
1,905
0,667
1,509
0,552
----

[#chapter-templating-helpers]
=== Nunjucks templating helpers

Nunjucks allows to define custom defined functions and filters that can be used in templates. To add extra functions and/or filters, define a file with .mjs extension exporting a HELPERS object. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/templating-helper/template-helpers.nunjucks.mjs[template-helpers.nunjucks.mjs]
[source,javascript]
----
export const HELPERS = {
  filters: {
    appendText: (str, text) => {
      return str + text
    }
  },
  functions: {
    double: (num) => {
      return 2 * num
    }
  }
}
----

The location of the file should then be given as the environment variable TEMPLATING_HELPERS_NUNJUCKS. External npm packages can be used in the templating helper file. See the sections on how start mocker for more information.
The functions and filters can then be used in rule definitions. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-templating-helpers.yaml[a-rule-with-templating-helpers.yaml]
[source,YAML]
----
name: using templating helpers
request:
  path: /templating-helpers
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  body: |
    result of function double: {{ double(req.query.q1) }}
    result of filter appendTest: {{ req.query.q2 | appendText('s') }}
----

Gives as result:
[source,console]
----
$ curl -i -X GET 'http://localhost:3000/templating-helpers?q1=2&q2=sheep'
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 65
Date: Sun, 09 Dec 2018 20:54:54 GMT
Connection: keep-alive

result of function double: 4
result of filter appendTest: sheeps
----

=== Echo server

The mock server can be used as an echo server to inspect all request parameters sent to the mock server. This can for example be useful when testing what headers are added by an api gateway or proxy.
A special template helper function "echo" has been defined and is available by default. To create an echo service, define a rule using the echo function. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/rules/a-rule-with-echo-server.yaml[a-rule-with-echo-server.yaml]
[source,YAML]
----
name: echo server
request:
  path: /echo
  method: POST
response:
  templatingEngine: nunjucks
  contentType: application/json
  statusCode: 200
  body: |
    {{ echo(req) }}
----

Gives as result:
[source,console]
----
$ curl -s -X POST 'http://localhost:3000/echo?q1=query1&q2=query2' -H 'content-type: application/json' -H 'X-h1: header1' -H 'X-h2: header2' -b 'c1=cookie1;c2=cookie2' -d '{ "my": { "input": "body" } }' | jq
{
  "method": "POST",
  "path": "/echo",
  "fullPath": "/echo?q1=query1&q2=query2",
  "body": {
    "my": {
      "input": "body"
    }
  },
  "params": {
    "q1": "query1",
    "q2": "query2"
  },
  "headers": {
    "host": "localhost:3000",
    "user-agent": "curl/7.47.0",
    "accept": "*/*",
    "content-type": "application/json",
    "x-h1": "header1",
    "x-h2": "header2",
    "content-length": "29"
  },
  "cookies": {
    "c1": "cookie1",
    "c2": "cookie2"
  }
}
----

[#chapter-projects]
== Projects

Rules are organized by projects. The projects are listed in a yaml file.

The project file in its simplest form looks like this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/projects/projects.yaml[projects.yaml]
[source,YAML]
----
projects:
  - name: examples
    rules:
      - ../rules/*.yaml
----

Each project defines the list of rules that belong to it. Rules can belong to several projects. The rules are reference by the path to the yaml rule file. This path can be an absolute path, or a path relative to the location of the project file. Glob patterns can be used (following the implemantation of the https://www.npmjs.com/package/glob[glob] package).

A more extensive example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/projects/projects-examples.yaml[projects-examples.yaml]
[source,YAML]
----
projects:
  - name: all rules in the rules directory
    rules:
      - ../rules/*.yaml
  - name: all rules in the rules directory and subdirectories
    rules:
      - ../rules/**/*.yaml
  - name: a defined list of rules
    rules:
      - ../rules/a-very-basic-rule.yaml
      - ../rules/a-basic-rule-with-templating.yaml
  - name: the rules containing the word latency or conditional in the file name
    rules:
      - ../rules/*latency*
      - ../rules/*conditional*
----

When using mocker a reference to the project file will always have to be given by setting environment variable MOCKER_PROJECTS_FILE. See below for more info on the different ways to use mocker.

== Mocker UI

Mocker UI is a browser-based UI to manage the projects and rules as described above. Instead of manipulating the yaml files manually, they can be managed from the UI. From the UI a mock server can also be started, as well as the learning mode.
Mocker UI provides:
* A section to manage projects: create new projects, update the name of a project, delete a projects, start a mock server for the project, and start a learnng mode reverse proxy for a project
* For a selected project the mock server rules belonging can be managed: create a rule, update a rule, delete a rule, and create a rule from an existing rule.
* For a selected project the captured requests of the learning mode reverse proxy server can be listed. For a captured request a new rule can be created based on the values of the captured request
* Administrative actions: manage the log level of the application

=== Start using node

Create a new project:

[source,console]
----
$ npm init
----

Install mocker-ui:

[source,console]
----
$ npm install @kroonprins/mocker-ui
----

Add a script to package.json:

[source,json]
----
  "scripts": {
    "start": "mocker-ui"
  }
----

Note: on Windows the shortcut need to be defined as follows instead:

[source,json]
----
  "scripts": {
    "start": "node --experimental-modules .\node_modules\@kroonprins\mocker-ui\start.mjs"
  }
----

Set the required environment variables by exporting them on the command line or by creating a .env file like for example this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-ui/.env[.env]
[source,properties]
----
MOCKER_PROJECTS_FILE=../projects/projects.yaml

TEMPLATING_HELPERS_NUNJUCKS=../templating-helper/template-helpers.nunjucks.mjs
----

After this Mocker UI can be started by running:

[source,console]
----
$ npm start
----

And then opening "http://localhost:3005" in the browser.
Starting Mocker UI will start a UI server on port 3005, an API server on port 3004 and an administration server on port 3001. These ports can be changed by setting environment variables (see below).

Alternatively Mocker UI can also be installed globally:

[source,console]
----
$ npm install -g @kroonprins/mocker-ui
----

And then started as follows:

[source,console]
----
$ mocker-ui
----

[#environment-variables-mocker-ui]
The possible environment variables are:

* *MOCKER_PROJECTS_FILE*: location of the projects file (see xref:chapter-projects[here]). If not provided it defaults to location ./projects/projects.yaml
* *MOCKER_LEARNING_MODE_DB_LOCATION* (optional): if you want to use the learning mode of the server, then add here the name of the file in which the captured requests should be stored. By default this will be ./data/learning_mode.db
* *TEMPLATING_HELPERS_NUNJUCKS* (optional): path to javascript file containing nunjucks templating helper functions/filters (see xref:chapter-templating-helpers[here])
* *MOCKER_RULES_DEFAULT_LOCATION* (optional): set the default location in which the yaml files of the rules will be stored when creating a rule from Mocker UI.
* *MOCKER_UI_SERVER_PORT* (optional): override the default port (3005) used by the UI server.
* *MOCKER_UI_SERVER_BIND_ADDRESS* (optional): bind the UI server to a given address instead of 0.0.0.0.
* *MOCKER_UI_SERVER_STATICS_LOCATION* (optional): override the location where the UI server statics are located.
* *MOCKER_ADMINISTRATION_SERVER_PORT* (optional): override the default port (3001) used by the administration server.
* *MOCKER_ADMINISTRATION_SERVER_BIND_ADDRESS* (optional): bind the administration server to a given address instead of 0.0.0.0.
* *MOCKER_API_SERVER_PORT* (optional): override the default port (3004) used by the api server.
* *MOCKER_API_SERVER_BIND_ADDRESS* (optional): bind the api server to a given address instead of 0.0.0.0.
* *MOCKER_LOG_LEVEL* (optional): set the log level (one of 'error', 'warn', 'info', 'debug', or 'trace')


If the nunjucks templating helpers require any npm packages then these can be added by installing the packages with npm. The templating helpers use modules so the package must be imported using the import syntax. For example:

[source,console]
----
$ npm install cows
----

[#nunjucks-templating-helper-with-cows]
And then use it in the templating helpers:

[source,javascript]
----
import cows from 'cows'

export const HELPERS = {
  functions: {
    printCow: () => {
      const cowsList = cows()
      return cowsList[Math.floor((Math.random() * (cowsList.length - 1)))]
    }
  }
}

----

=== Start using docker

[source,console]
----
$ docker run --rm \
  -p 3001:3001 -p 3004:3004 -p 8000:3005 -p 8001:8080 \
  -v $(pwd)/projects:/app/projects \
  -v $(pwd)/rules:/app/rules \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/template-helpers.nunjucks.mjs:/app/template-helpers.nunjucks.mjs \
  kroonprins/mocker-ui:latest \
  npm start
----

Ports 3001, 3004 and 3005 must be mapped. The port on which port 3005 maps on the docker host can be chosen freely (port 8000 in the example above). For ports 3004 and 3005 the port must map to the same port on the docker host, but the port can be changed by using the environment variables described xref:environment-variables-mocker-ui[here]. When starting a mock server or the learning mode from Mocker UI then this port must also be mapped. In the example above, from Mocker UI a mock server is started on port 8080 and this is mapped on port 8001 on the docker host.

The projects file and the directory mock server rules must also be mapped into the container via volume mapping. In the example above the projects file is in $(pwd)/projects on the docker host, and the mock server rules are in $(pwd)/rules on the docker host.

The environment variables to configure Mocker UI (see xref:environment-variables-mocker-ui[here]) can be passed as part of the docker run command with the -e option (e.g. docker run -e "TEMPLATING_HELPERS_NUNJUCKS=./template-helpers.nunjucks.mjs") or by putting them in a .env file that is mapped into the container as in the example above.

In case nunjucks templating helpers are used, then the helpers .mjs file should also be mapped in the container as shown in the example above.
If the nunjucks templating helpers require any npm packages then a new image must be built in which the dependency is installed. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-ui-with-docker/Dockerfile[Dockerfile]
[source,console]
----
from kroonprins/mocker-ui

RUN npm install cows
----

And define a template-helpers.nunjucks.mjs that uses the cows package: see xref:nunjucks-templating-helper-with-cows[here].

Then build the image:

[source,console]
----
$ docker build -t mocker-ui-with-cows .
----

And define a rule using the templating helper (or create if from the UI after starting it):

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-ui-with-docker/rules/rule-using-nunjucks-templating-helper-with-external-package.yaml[rule-using-nunjucks-templating-helper-with-external-package.yaml]
[source,YAML]
----
name: rule using the printCow templating helper
request:
  path: /cow
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  body: |
    {{printCow()}}
----

And run it:

[source,console]
----
$ docker run --rm \
  -p 3001:3001 -p 3004:3004 -p 8000:3005 -p 8001:8080 \
  -v $(pwd)/projects:/app/projects \
  -v $(pwd)/rules:/app/rules \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/template-helpers.nunjucks.mjs:/app/template-helpers.nunjucks.mjs \
  mocker-ui-with-cows \
  npm start
----

After starting a mock server on port 8080 binding to 0.0.0.0, then the result is:
[source,console]
----
$ curl -X GET http://localhost:8001/cow
        (__)
        (oo)
*+-------\/
||______||
  ||----||
  OO    OO
 pickup cow
----


== Mock server standalone

A mock server can also be started in standalone mode from the command line.

[#chapter-swagger-ui]
=== Swagger UI

It is possible to start swagger UI next to a mock server. A swagger definition will be generated from the mock server rules. This swagger definition can be consulted from the swagger UI. See chapters below on how to activate the swagger server.

=== Adminstration server

Next to the mock server an administration server will be started. The adminstration will run on a separate port, by default 3007 but can be specified with the environment variable MOCKER_MOCK_SERVER_ADMINISTRATION_SERVER_PORT.

[#chapter-administration-server-log-level]
==== Set log level

By default the mock server logs to the console with log level "info". This log level can be changed by calling the adminstration server. Possible log levels are 'error', 'warn', 'info', 'debug', or 'trace'.

To update the log level globally:

[source,console]
----
$ curl -i -X PUT http://localhost:3007/administration/loglevel -d '{ "level": "debug" }' -H "Content-Type: application/json"
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Date: Fri, 14 Dec 2018 19:47:30 GMT
Connection: keep-alive
Content-Length: 0
----

It is possible to let the log level revert to its original after a given number of milliseconds:

[source,console]
----
$ curl -i -X PUT http://localhost:3007/administration/loglevel -d '{ "level": "debug", "maxAge": "60000" }' -H "Content-Type: application/json"
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Date: Fri, 14 Dec 2018 19:47:30 GMT
Connection: keep-alive
Content-Length: 0
----

Will set the log level to debug and revert to the previous log level after 1 minute.

It is also possible to update the level of only one specific logger. The list of specific loggers can be retrieved from the administration server:

[source,console]
----
$ curl -s -X GET http://localhost:3007/administration/loglevel | jq
{
  "parent": {},
  "children": [
    {
      "id": "config.service",
      "level": "info"
    },
    ...
  ]
}
----

The loglevel for one of these loglevels can then be updated:

[source,console]
----
$ curl -i -X PUT http://localhost:3007/administration/loglevel/config.service -d '{ "level": "debug" }' -H "Content-Type: application/json"
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Date: Fri, 14 Dec 2018 19:55:47 GMT
Connection: keep-alive
Content-Length: 0
----

Also here the "maxAge" can be added to the request body to revert the log level after a given number of milliseconds.

==== Get metrics

Metrics about the number of requests the mock server has handled can be requested from the administration server.

For example, just after the mock server started:

[source,console]
----
$ curl -s -X GET http://localhost:3007/administration/metrics  | jq
{
  "starts": {
    "examples": [
      {
        "timestamp": 1544815770889,
        "port": 3000,
        "project": "examples",
        "watchConfigurationChanges": false,
        "enableSwaggerUI": false
      }
    ]
  },
  "totalRequests": {},
  "requestsPerRule": {}
}
----

The "starts" section in the response lists the times the mock server has started for a given project ("examples" is the project) and with which configuration.

After the mock server has handled some requests:

[source,console]
----
$ curl -s -X GET http://localhost:3007/administration/metrics  | jq
{
  "starts": {
    "examples": [
      {
        "timestamp": 1544815770889,
        "port": 3000,
        "project": "examples",
        "watchConfigurationChanges": false,
        "enableSwaggerUI": false
      }
    ]
  },
  "totalRequests": {
    "examples": 7
  },
  "requestsPerRule": {
    "examples": {
      "../rules/a-rule-with-path-parameter.yaml": 4,
      "../rules/a-very-basic-rule.yaml": 2,
      "../rules/a-basic-rule-with-templating.yaml": 1
    }
  }
}
----

The "totalRequest" section is the total requests per project ("examples" is the project). The "requestsPerRule" section gives the breakdown of number of requests per rule.

=== Start using node

Create a new project:

[source,console]
----
$ npm init
----

Install mocker-mock-server:

[source,console]
----
$ npm install @kroonprins/mocker-mock-server
----

Add a script to package.json:

[source,json]
----
  "scripts": {
    "start": "mocker-mock-server"
  }
----

Note: on Windows the shortcut need to be defined as follows instead:

[source,json]
----
  "scripts": {
    "start": "node --experimental-modules .\node_modules\@kroonprins\mocker-mock-server\start.mjs"
  }
----

Set the required environment variables by exporting them on the command line or by creating a .env file like for example this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server/.env[.env]
[source,properties]
----
MOCKER_PROJECTS_FILE=../projects/projects.yaml
MOCKER_PROJECT=examples

TEMPLATING_HELPERS_NUNJUCKS=./template-helpers.nunjucks.mjs

MOCKER_MOCK_SERVER_WATCH_FOR_FILE_CHANGES=true
MOCKER_MOCK_SERVER_SWAGGER_UI_ENABLED=true
----

After this the mock server can be started by running:

[source,console]
----
$ npm start
----

The mock server can then be called on "http://localhost:3000". Swagger UI, if activated, can be opened in the browser on http://localhost:3006.

Alternatively Mocker mock server can also be installed globally:

[source,console]
----
$ npm install -g @kroonprins/mocker-mock-server
----

And then started as follows:

[source,console]
----
$ mocker-mock-server
----

[#environment-variables-mocker-mock-server]
The possible environment variables are:

* *MOCKER_PROJECTS_FILE*: location of the projects file (see xref:chapter-projects[here]). If not provided it defaults to location ./projects/projects.yaml
* *MOCKER_PROJECT* (optional): reference to the name of the project to run the mock server for.
* *TEMPLATING_HELPERS_NUNJUCKS* (optional): path to javascript file containing nunjucks templating helper functions/filters (see xref:chapter-templating-helpers[here])
* *MOCKER_MOCK_SERVER_PORT* (optional): override the default port (3000) used by the mock server.
* *MOCKER_MOCK_SERVER_BIND_ADDRESS* (optional): bind the mock server to a given address instead of 0.0.0.0.
* *MOCKER_MOCK_SERVER_WATCH_FOR_FILE_CHANGES* (optional): if set to true, a running mock server will watch the filesystem for changes to project rule files, and automatically restart itself when this happen to load the latest configuration.
* *MOCKER_MOCK_SERVER_SWAGGER_UI_ENABLED* (optional): enable swagger UI on the mock server (see xref:chapter-swagger-ui[here]).
* *MOCKER_MOCK_SERVER_SWAGGER_UI_PORT* (optional): override the default port (3006) used by the swagger UI server.
* *MOCKER_MOCK_SERVER_SWAGGER_UI_BIND_ADDRESS* (optional): bind the swagger UI server to a given address instead of 0.0.0.0.
* *MOCKER_MOCK_SERVER_ADMINISTRATION_SERVER_PORT* (optional): override the default port (3007) used by the administration server.
* *MOCKER_MOCK_SERVER_ADMINISTRATION_SERVER_BIND_ADDRESS* (optional): bind the administration server to a given address instead of 0.0.0.0.
* *MOCKER_LOG_LEVEL* (optional): set the log level (one of 'error', 'warn', 'info', 'debug', or 'trace')


If the nunjucks templating helpers require any npm packages then these can be added by installing the packages with npm. The templating helpers use modules so the package must be imported using the import syntax. For example:

[source,console]
----
$ npm install cows
----

And then use it in the templating helpers like was done xref:nunjucks-templating-helper-with-cows[here].

=== Start using docker

[source,console]
----
$ docker run --rm \
  -p 8000:3000 -p 8001:3006 -p 8002:3007 \
  -v $(pwd)/projects:/app/projects \
  -v $(pwd)/rules:/app/rules \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/template-helpers.nunjucks.mjs:/app/template-helpers.nunjucks.mjs \
  kroonprins/mocker-mock-server:latest \
  npm start
----

Ports 3000 must be mapped, port 3006 only if the Swagger UI is activated, port 3007 only if interested to access the adminstration server. The port on which port 3000, 3006 and 3007 map on the docker host can be chosen freely (ports 8000, 8001 and 8002 respectively in the example above).

The projects file and the directory mock server rules must also be mapped into the container via volume mapping. In the example above the projects file is in $(pwd)/projects on the docker host, and the mock server rules are in $(pwd)/rules on the docker host.

The environment variables to configure the standalone mock server (see xref:environment-variables-mocker-mock-server[here]) can be passed as part of the docker run command with the -e option (e.g. docker run -e "TEMPLATING_HELPERS_NUNJUCKS=./template-helpers.nunjucks.mjs") or by putting them in a .env file that is mapped into the container as in the example above.

In case nunjucks templating helpers are used, then the helpers .mjs file should also be mapped in the container as shown in the example above.
If the nunjucks templating helpers require any npm packages then a new image must be built in which the dependency is installed. For example:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server-with-docker/Dockerfile[Dockerfile]
[source,console]
----
from kroonprins/mocker-mock-server

RUN npm install cows
----

And define a template-helpers.nunjucks.mjs that uses the cows package: see xref:nunjucks-templating-helper-with-cows[here].

Then build the image:

[source,console]
----
$ docker build -t mocker-mock-server-with-cows .
----

And define a rule using the templating helper (or create if from the UI after starting it):

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server-with-docker/rules/rule-using-nunjucks-templating-helper-with-external-package.yaml[rule-using-nunjucks-templating-helper-with-external-package.yaml]
[source,YAML]
----
name: rule using the printCow templating helper
request:
  path: /cow
  method: GET
response:
  templatingEngine: nunjucks
  contentType: text/plain
  statusCode: 200
  body: |
    {{printCow()}}
----

And run it:

[source,console]
----
$ docker run --rm \
  -p 8000:3000 -p 8001:3006 \
  -v $(pwd)/projects:/app/projects \
  -v $(pwd)/rules:/app/rules \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/template-helpers.nunjucks.mjs:/app/template-helpers.nunjucks.mjs \
  mocker-mock-server-with-cows \
  npm start
----

The mock server can then be called at http://localhost:8000 and the result is:
[source,console]
----
$ curl -X GET http://localhost:8000/cow
           (  )
           (oo)
  /---*-.---\/
 / |* . * .||
*  ||------||
   ~~      ~~

 Cow w/ cowpox
----

Opening http://localhost:8001 in a browser will open swagger UI.

== Learning mode standalone

The learning mode reverse proxy can also be started in standalone mode from the command line.

=== Adminstration server

Next to the learning mode server an administration server will be started. The adminstration will run on a separate port, by default 3008 but can be specified with the environment variable MOCKER_LEARNING_MODE_SERVER_ADMINISTRATION_SERVER_PORT.

[#chapter-administration-server-log-level]
==== Set log level

The log levels can be managed through the administration server in the same way as described xref:chapter-administration-server-log-level[here]

==== Get metrics

Similarly as for a standalone mock server, metrics about the number of requests the learning mode server has handled can be requested from the administration server.

For example, just after the learning mode server started:

[source,console]
----
$ curl -s -X GET http://localhost:3008/administration/metrics  | jq
{
  "starts": {
    "examples": [
      {
        "timestamp": 1544821640233,
        "port": 3002,
        "project": "examples"
      }
    ]
  },
  "totalRequests": {}
}
----

The "starts" section in the response lists the times the learning mode server has started for a given project ("examples" is the project) and with which configuration.

After the learning mode server has proxied some requests:

[source,console]
----
$ curl -s -X GET http://localhost:3007/administration/metrics  | jq
{
  "starts": {
    "examples": [
      {
        "timestamp": 1544821640233,
        "port": 3002,
        "project": "examples"
      }
    ]
  },
  "totalRequests": {
    "examples": 2
  }
}
----

The "totalRequest" section is the total requests per project ("examples" is the project).

=== Start using node

Create a new project:

[source,console]
----
$ npm init
----

Install mocker-learning-mode:

[source,console]
----
$ npm install @kroonprins/mocker-learning-mode
----

Add a script to package.json:

[source,json]
----
  "scripts": {
    "start": "mocker-learning-mode"
  }
----

Note: on Windows the shortcut need to be defined as follows instead:

[source,json]
----
  "scripts": {
    "start": "node --experimental-modules .\node_modules\@kroonprins\mocker-learning-mode\start.mjs"
  }
----

Set the required environment variables by exporting them on the command line or by creating a .env file like for example this:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-learning-mode/.env[.env]
[source,properties]
----
MOCKER_PROJECTS_FILE=../projects/projects.yaml
MOCKER_PROJECT=examples

MOCKER_LEARNING_MODE_DB_LOCATION=./captured-requests.db
MOCKER_LEARNING_MODE_REVERSE_PROXY_SERVER_TARGET_HOST=http://httpbin.org
----

After this the mock server can be started by running:

[source,console]
----
$ npm start
----

The mock server can then be called on "http://localhost:3002". The request will be proxied to the host specified by the environment variable MOCKER_LEARNING_MODE_REVERSE_PROXY_SERVER_TARGET_HOST (http://httpbin.org in the example above) and the request/response will be stored in a file-based database with location specified by the environment variable MOCKER_LEARNING_MODE_DB_LOCATION.

Alternatively Mocker learning mode can also be installed globally:

[source,console]
----
$ npm install -g @kroonprins/mocker-learning-mode
----

And then started as follows:

[source,console]
----
$ mocker-learning-mode
----

[#environment-variables-mocker-learning-mode]
The possible environment variables are:

* *MOCKER_PROJECTS_FILE*: location of the projects file (see xref:chapter-projects[here]). If not provided it defaults to location ./projects/projects.yaml
* *MOCKER_PROJECT* (optional): reference to the name of the project to run the mock server for.
* *MOCKER_LEARNING_MODE_DB_LOCATION* (optional): the name of the file in which the captured requests should be stored. By default this will be ./data/learning_mode.db
* *MOCKER_LEARNING_MODE_REVERSE_PROXY_SERVER_PORT* (optional): override the default port (3002) used by the learning mode reverse proxy server.
* *MOCKER_LEARNING_MODE_REVERSE_PROXY_SERVER_BIND_ADDRESS* (optional): bind the learning mode reverse proxy server to a given address instead of 0.0.0.0.
* *MOCKER_LEARNING_MODE_REVERSE_PROXY_SERVER_TARGET_HOST*: indicates the downstream server to which the learning mode reverse proxy server should proxy the requests.
* *MOCKER_LEARNING_MODE_SERVER_ADMINISTRATION_SERVER_PORT* (optional): override the default port (3008) used by the administration server.
* *MOCKER_LEARNING_MODE_SERVER_ADMINISTRATION_SERVER_BIND_ADDRESS* (optional): bind the administration server to a given address instead of 0.0.0.0.
* *MOCKER_LOG_LEVEL* (optional): set the log level (one of 'error', 'warn', 'info', 'debug', or 'trace')

The database with captured requests can then be used in Mocker UI to create rules for a mock server.

=== Start using docker

[source,console]
----
$ docker run --rm \
  -p 8000:3002 -p 8001:3008 \
  -v $(pwd)/projects:/app/projects \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/data:/app/data \
  kroonprins/mocker-learning-mode:latest \
  npm start
----

Ports 3002 must be mapped, port 3008 only if interested to access the adminstration server. The port on which port it maps on the docker host can be chosen freely (port 8000 and 8001 in the example above).

The projects file must also be mapped into the container via volume mapping. In the example above the projects file is in $(pwd)/projects on the docker host, and the mock server rules are in $(pwd)/rules on the docker host.

The environment variables to configure the standalone learning mode reverse proxy server (see xref:environment-variables-mocker-learning-mode[here]) can be passed as part of the docker run command with the -e option (e.g. docker run -e "MOCKER_LEARNING_MODE_DB_LOCATION=/app/data/captured-requests.db") or by putting them in a .env file that is mapped into the container as in the example above.

The database with captured request will be written to the file specified by the environment variable MOCKER_LEARNING_MODE_DB_LOCATION inside the container. To get it out of the container, the directory of this file should be mapped on the docker host.

After docker is started requests can be sent to http://localhost:8000 and they will be forwarded to the host specified by environment variable MOCKER_LEARNING_MODE_REVERSE_PROXY_SERVER_TARGET_HOST. Note that this target host must be reachable from within the container. This can be for example a host on the internet, or another application running in another container reachable thanks to docker-compose.

For example:

With following .env file:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-learning-mode-with-docker/.env[.env]
[source,properties]
----
MOCKER_PROJECT=examples

MOCKER_LEARNING_MODE_DB_LOCATION=/app/data/captured-requests.db
MOCKER_LEARNING_MODE_REVERSE_PROXY_SERVER_TARGET_HOST=http://httpbin.org
----

After starting the learning mode reverse proxy server with the docker command above, requests can be captured:

[source,console]
----
$ curl -X GET http://localhost:8000/get
{
  "args": {},
  "headers": {
    "Accept": "*/*",
    "Connection": "close",
    "Host": "httpbin.org",
    "User-Agent": "curl/7.47.0"
  },
  "origin": "213.219.166.27",
  "url": "http://httpbin.org/get"
}
----

And a record will have been written in $(pwd)/data/captured-requests.db:
[source,console]
----
$ wc -l ./data/captured-requests.db
1 ./data/captured-requests.db
----

== Use in unit/integration tests

The package @kroonprins/mocker-mock-server-test can be used to start a mock server during automated tests (unit/integration/E2E). Expectations about how the mock server was called during the test can be verified.

This can be useful to test a services that executes one or more HTTP calls to other services. This other service will be mocked by the mock server during the test. After the test has called the service under test, it can be verified that the service called the other services as expected by asking the mock server what requests it received with which request attributes.

[#chapter-test-mock-server-es6]
=== ES6 modules

Mocker has been written with ES6 modules. ES6 modules are still experimental (only available if node is run with the --experimental-modules flag) meaning that support of common test runners for ES6 modules is close to non-existent. However, for the time being, tests written with ES6 modules can use the mock server as follows.

Install @kroonprins/mocker-mock-server-test in your project:

[source,console]
----
$ npm install --save-dev @kroonprins/mocker-mock-server-test
----

Create a test that (usually indirectly) calls the mock server. For example, where the mock server is called directly, to keep the example short:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server-test/experimental-modules/test-by-file.mjs[test-by-file.mjs]
[source,javascript]
----
import axios from 'axios'
import chai from 'chai'
import { MockServer } from '@kroonprins/mocker-mock-server-test'

const expect = chai.expect

const test = async () => {
  const mockServer = new MockServer({
    port: 0,
    ruleLocation: [ 'test-rule-1.yaml', 'test-rule-2.yaml' ]
  })

  try {
    await mockServer.start()

    const response = await axios.post(`http://localhost:${mockServer.port}/test1/parameter1?query1=q1&query2=q2`, 'inputBody', {
      headers: {
        'Content-Type': 'text/plain',
        'X-test1': 'h1',
        'X-test2': 'h2',
        'Cookie': 'cookie1=c1; cookie2=c2'
      }
    })
    expect(response.status).to.equal(200)

    expect(mockServer.global().invocations()).to.equal(1)
    expect(mockServer.for('/test1/:p1', 'POST').invocations()).to.equal(1)
    expect(mockServer.for('/test2/:p2', 'POST').invocations()).to.equal(0)
    expect(mockServer.for('/test1/:p1', 'POST').ruleName()).to.equal('test rule 1')
    expect(mockServer.for('/test1/:p1', 'POST').ruleLocation()).to.equal('test-rule-1.yaml')
    expect(mockServer.for('/test1/:p1', 'POST').path()).to.equal('/test1/parameter1')
    expect(mockServer.for('/test1/:p1', 'POST').fullPath()).to.equal('/test1/parameter1?query1=q1&query2=q2')
    expect(mockServer.for('/test1/:p1', 'POST').header('X-test1')).to.equal('h1')
    expect(mockServer.for('/test1/:p1', 'POST').header('X-test2')).to.equal('h2')
    expect(mockServer.for('/test1/:p1', 'POST').header('X-test3')).to.equal(undefined)
    expect(mockServer.for('/test1/:p1', 'POST').cookie('cookie1')).to.equal('c1')
    expect(mockServer.for('/test1/:p1', 'POST').cookie('cookie2')).to.equal('c2')
    expect(mockServer.for('/test1/:p1', 'POST').cookie('cookie3')).to.equal(undefined)
    expect(mockServer.for('/test1/:p1', 'POST').query('query1')).to.equal('q1')
    expect(mockServer.for('/test1/:p1', 'POST').query('query2')).to.equal('q2')
    expect(mockServer.for('/test1/:p1', 'POST').query('query3')).to.equal(undefined)
    expect(mockServer.for('/test1/:p1', 'POST').body()).to.equal('inputBody')

    expect(mockServer.name('test rule 1').invocations()).to.equal(1)
    expect(mockServer.name('test rule 2').invocations()).to.equal(0)
  } finally {
    await mockServer.stop()
  }
}

test()
----

Step by step:

First import the test mock server using ES6 modules import syntax:

[source,javascript]
----
import { MockServer } from '@kroonprins/mocker-mock-server-test'
----

Configure and start the mock server:

[source,javascript]
----
const mockServer = new MockServer({
  port: 0,
  ruleLocation: [ 'test-rule-1.yaml', 'test-rule-2.yaml' ]
})

await mockServer.start()
----

The configuration options are:

* *port*: a specific port, or if 0 is given then a random free port will be selected. If a random port is chosen, then the selected port is accessible as mockServer.port _after_ the server has started
* *ruleLocation*: the rule(s) for the mock server can be provided in different ways. The first is by referencing a yaml file with the rule. The path to the file should be either an absolute path or a path relative to where the test will be run from. The value can be either a list or just one value, and glob patterns are allowed. So the following are all valid:
** ruleLocation: [ 'test-rule-1.yaml', 'test-rule-2.yaml' ]
** ruleLocation: 'test-rule-1.yaml'
** ruleLocation: '\**/*.yaml'
** ruleLocation: [ 'test-rule-1*.yaml', 'test-rule-2*.yaml' ]
* *rule*: the other way is to put the parsed yaml directly as an object, or a list of objects. For example:
+
[source,javascript]
----
const mockServer = new MockServer({
  port: 0,
  rule: [ {
    name: 'test rule 1',
    request: {
      method: 'POST',
      path: '/test1'
    },
    response: {
      templatingEngine: 'none',
      statusCode: 200,
      contentType: 'text/plain',
      body: 'rule 1'
    }
  }, {
    name: 'test rule 2',
    request: {
      method: 'POST',
      path: '/test2'
    },
    response: {
      templatingEngine: 'none',
      statusCode: 200,
      contentType: 'text/plain',
      body: 'rule 2'
    }
  } ]
})
----
+
Also here it can be either a list or a single value.

After a request to the server has happened, expectations can be verified:

[source,javascript]
----
// Verify the global number of requests is as expected.
expect(mockServer.global().invocations()).to.equal(1)

// Verify the number requests to a specific rule is as expected.
// The .for(path, method) refers to the path and method as defined in the rule.
expect(mockServer.for('/test1/:p1', 'POST').invocations()).to.equal(1)
expect(mockServer.for('/test2/:p2', 'POST').invocations()).to.equal(0)

// Verify that the expected rule was called.
expect(mockServer.for('/test1/:p1', 'POST').ruleName()).to.equal('test rule 1')
expect(mockServer.for('/test1/:p1', 'POST').ruleLocation()).to.equal('test-rule-1.yaml')

// Verify the path and full path that was received
expect(mockServer.for('/test1/:p1', 'POST').path()).to.equal('/test1/parameter1')
expect(mockServer.for('/test1/:p1', 'POST').fullPath()).to.equal('/test1/parameter1?query1=q1&query2=q2')

// Verify that certain headers were received
expect(mockServer.for('/test1/:p1', 'POST').header('X-test1')).to.equal('h1')
expect(mockServer.for('/test1/:p1', 'POST').header('X-test2')).to.equal('h2')
expect(mockServer.for('/test1/:p1', 'POST').header('X-test3')).to.equal(undefined)

// Verify that certain headers were received
expect(mockServer.for('/test1/:p1', 'POST').cookie('cookie1')).to.equal('c1')
expect(mockServer.for('/test1/:p1', 'POST').cookie('cookie2')).to.equal('c2')
expect(mockServer.for('/test1/:p1', 'POST').cookie('cookie3')).to.equal(undefined)

// Verify that certain query parameters were received
expect(mockServer.for('/test1/:p1', 'POST').query('query1')).to.equal('q1')
expect(mockServer.for('/test1/:p1', 'POST').query('query2')).to.equal('q2')
expect(mockServer.for('/test1/:p1', 'POST').query('query3')).to.equal(undefined)

// Verify that the received body is as expected
expect(mockServer.for('/test1/:p1', 'POST').body()).to.equal('inputBody')

// Rules can also be referred to by name instead of path and method.
// In this case the .name(name) is used instead of .for(path, method).
expect(mockServer.name('test rule 1').invocations()).to.equal(1)
expect(mockServer.name('test rule 2').invocations()).to.equal(0)
----

=== CommonJS

Using ES6 code from CommonJS code is possible with the dynamic import statement. As dynamic import is async this is less straightforward as using require() to import another CommonJS dependency. Even still in the well known test runners using a dynamic import seems to result in errors. Therefor a CommonJS compatible version of the test mocker is also made available, while waiting for ES6 modules to lose its experimental status in node. To use it with for example the mocha test runner:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server-test/commonjs/test.js[test.js]
[source,javascript]
----
const expect = require('chai').expect
const axios = require('axios')
const MockServer = require('@kroonprins/mocker-mock-server-test/cjs/exports').MockServer

let mockServer

before(async function () {
  mockServer = new MockServer({
    port: 0,
    rule: {
      request: {
        method: 'GET',
        path: '/test'
      },
      response: {
        templatingEngine: 'none',
        statusCode: 200,
        contentType: 'text/plain',
        body: 'response body'
      }
    }
  })
  await mockServer.start()
})

describe('A test requiring a mock server', function () {
  it('should expect the rule to get one invocation', async function () {
    await axios.get(`http://localhost:${mockServer.port}/test`)

    expect(mockServer.for('/test', 'GET').invocations()).to.equal(1)
  })
})

after(function () {
  mockServer.stop()
})
----

Here it is important to use the import the cjs specific version `@kroonprins/mocker-mock-server-test/cjs/exports`. See https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server-test/commonjs[here] for the full sample, which can be run with `npm test`.

All configuration options and methods available on the test mock server are the same as given in xref:chapter-test-mock-server-es6[this chapter].

=== TypeScript

With TypeScript there are similar issues to use the ES6 modules directly because TypeScript currently does not compile yet to mjs (https://github.com/Microsoft/typescript/issues/18442) also awaiting ES6 to lose its experimental status in node. So in the meantime it is also needed to use the CommonJS version of the test mock server. Typings have been added for easy use in TypeScript.
. To use it with for example the mocha test runner:

.https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server-test/typescript/test.ts[test.ts]
[source,typescript]
----
import { expect } from 'chai'
import 'mocha'
import axios from 'axios'
import { MockServer } from '@kroonprins/mocker-mock-server-test/cjs/exports'

let mockServer: MockServer

before(async function () {
  mockServer = new MockServer({
    port: 0,
    rule: {
      request: {
        method: 'GET',
        path: '/test'
      },
      response: {
        templatingEngine: 'none',
        statusCode: 200,
        contentType: 'text/plain',
        body: 'response body'
      }
    }
  })
  await mockServer.start()
})

describe('A TypeScript test requiring a mock server', function () {
  it('should expect the rule to get one invocation', async function () {
    await axios.get(`http://localhost:${mockServer.port}/test`)

    expect(mockServer.for('/test', 'GET').invocations()).to.equal(1)
  })
})

after(function () {
  mockServer.stop()
})
----

Here it is important to use the import the cjs specific version `@kroonprins/mocker-mock-server-test/cjs/exports`. See https://github.com/kroonprins/mocker/blob/master/packages/mocker-doc/use-mocker-mock-server-test/typescript[here] for the full sample, which can be run with `npm test`.

All configuration options and methods available on the test mock server are the same as given in xref:chapter-test-mock-server-es6[this chapter].

